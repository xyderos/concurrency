# Signals

Handle/Respond to __asynchronous events__

_Obviously, polling is expensive at best_

* Signals __interrupt__ programs to execute some code based on an arisen event

* You need to declare which __code you need to execute based on which signal you expect to receive__

* You can __mask some signals__ in order to indicate that you do not need to handle them at a specific point

* Signals are usually generated from __external processes__

Workflow:

1) The __kernel__ looks at the __signal mask__ and the __dispatch table__ to figure out what __code to execute__
2) The kernel will __interrupt the process__
3) The kernel will push the __state into the stack__
4) And will initialize the chosen signal handler
5) The handler can do __nothing__, __something__, or even __jump to a different execution point__

* If several __similar signals__ are sent to a process, __at least one signal will be delivered in the process after the last one was sent__

* You __cannot count signals__, it is just a mechanism to make sure __a process will pay attention to something, but its up to the process on what to do__

You will be using signals for __three reasons__

1) #### __Error reporting__

_eg divide by zero, access unmapped memory_

* The hardware takes a __trap__ on the illegal instruction
* The __trap handler__ is run by the kernel
* The kernel will figure out what to do
* Will __signal the process__ (keep in mind that the __process has halted on the illegal instruction__)

Signals that are generated by traps are known as __synchronous signals__

The signal __must be delivered to the offending thread__

* Declare a __signal handler__

#### __Situation reporting__

___Asynchronous signal__ delivery that something changed and needs attention_

eg SIGWINCH, change the size of the window

* You are absolutely fine, you just need to do something extra

* The situations are linked to the __process__ (thats why the process has the __signal dispatch table__) and thus we only have a set of signal handlers __per process__

The library decides which thread to run the __signal handler__ based on:

1) The state of the __signal mask__
2) Priority
3) Run state

In general, __implementation dependent__

* __You just need to set the thread signal mask__

#### __Interruption__

___Asynchronous signal__ delivery indicating that you need to stop what you are doing and do something else_

eg A process is stalled, send a SIGALRM and handle it accordingly

There is a potential issue, there is no defined standard on __how to handle an interruption__

* Multithreaded programs are __already asynchronous__, a program __can spawn a thread to wait for whatever eventa we are interested in__ but you __still need to deal with signals__

Why?

* Some programs __still use signals__
* __Interrupts to individual threads__

Each thread has its own __individual thread mask__ and decide what __signal to accept__
* __All you should care is that you set the signal mask and the library will do the scheduling for you__

You __can send signals__ eg __kill__

* If the program you sent the signal has __masked them out__, they will go to the pending queue __until the masking situation changes__

Some words on __signal safety__

Imagine a situation where you you call malloc in a thread and a signal came in. Now, imagine that the signal handler also calls malloc. Malloc, by definition requires you to lock on some data. If the threads malloc acquires the lock, and then in the signal handler the lock is not released yet, you have a __deadlock__

The best solution would to use __sigwait__ instead of having signal handlers

#### __An example of how threads receive signals and how they handle them, study case : Solaris__

Solaris has a distinguished bound thread that handles all signal delivery issues. 

This is created upon startup and promptly calls __sigwait__ which basically instructs to wait for any signals you ask it to. All the signals will be delivered to it. 

When a signal is delivered to the process, this thread looks at all the user threads and decides which thread will run the signal handler based on __mask, state and priority__. The thread __will be interrupted.__

If your thread calls __sigwait__, this will inform the polling thread about your desires.

#### __About signal handlers__

__Avoid it!__ 

_not many cases require that_

* __Dedicate a thread just to handle all the signals based on the signal handler__

* Create it and have it __block__, doenst matter if its sleeping, __the library will wake it up__

```
pthread_sigmask(SIG_UNBLOCK, signal_set, NULL);
sigaction(signal_handler...)
// sleep
SEM_WAIT(&s); 
```
A better solution would be __sigwait__
 ```
pthread_sigmask(SIG_BLOCK, signal_set, NULL);
sigwait(&signal_set, &signal);
switch(signal)
{ 
    case SIGALRM:
        run_alarm();
        break;
    case SIGUSR1
        run_usr1();
        break;
}
 ```

#### __Alarms__

Issue:

It is common for a thread to accept __alarms__, eg you are doing IO to something unreliable and this should stop

__This is not included in the POSIX standard__

Solution:

Wrtie a thread specific timer call out queue for SIGALRM

* __Keep track of which thread is waiting for an alarm and when the alarm goes off you need to deliver that signal__

A possible workflow:

1) __The waiter thread is spawned upon initialization__
2) Block all signals set up a handler for __sigusr1__ and enter the __sigwait loop__
3) Few threads spawn and only one of then unblocks __sigusr1__ and __sets a timer__
4) When the alarm goes off, the waiter returns from __sigwait__, figures out which thread requested the alarm and send the __sigusr1__ to that thread
5) The thread will run the handler
6) You might need to keep track of who requested the alarm and also be able to reset it

```
waiter()
{
    nt sig;
    sigset_t set;
    init_set(&set);
    while(1)
    {
        err = sigwait(&set, &sig);
        switch(sig)
        {
            case SIGALRM : 
                tell_thr();
                break;
            case SIGUSR1 : 
                do_usr1();
                break;
        }
    }
}
```

#### __Threads for events__

* Realtime can have asynchronous IO, you cant wait for it to complete, but what you can do is to specify a callback to happen when it does complete

* Usually, you generate a signal, which you will handle based on the data you probably received

* You can tell the library to make a thread for you!

```
struct sigevent event;
event.sigev_notify = SIGEV_THREAD;
event.sigev_value.sival_int = 100;
event.sigev_attributes = attr;
event.sigev_notify_function = handler;
```